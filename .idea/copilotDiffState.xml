<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/LICENSE">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/LICENSE" />
              <option name="updatedContent" value="MIT License&#10;&#10;Copyright (c) 2025&#10;&#10;Permission is hereby granted, free of charge, to any person obtaining a copy&#10;of this software and associated documentation files (the &quot;Software&quot;), to deal&#10;in the Software without restriction, including without limitation the rights&#10;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#10;copies of the Software, and to permit persons to whom the Software is&#10;furnished to do so, subject to the following conditions:&#10;&#10;The above copyright notice and this permission notice shall be included in all&#10;copies or substantial portions of the Software.&#10;&#10;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#10;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#10;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#10;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#10;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#10;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#10;SOFTWARE.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Obsidianite&#10;&#10;A simple Python package to process Obsidian Markdown Notes.&#10;&#10;## Features&#10;- Load, process, and save Obsidian-compatible Markdown notes&#10;- Parse YAML front matter and note content&#10;- Work with collections of notes in a directory&#10;&#10;## Installation&#10;&#10;This project uses [uv](https://github.com/astral-sh/uv) for dependency management and installation.&#10;&#10;To install the project dependencies, run:&#10;&#10;```bash&#10;uv sync&#10;```&#10;&#10;Or, if you want to install the project in editable mode:&#10;&#10;```bash&#10;uv pip install -e .&#10;```&#10;&#10;## Testing&#10;&#10;To run the tests, use:&#10;&#10;```bash&#10;uv run pytest -v&#10;```&#10;&#10;## Usage Example&#10;&#10;```python&#10;from obsidianite import Note, Notes&#10;&#10;# Load a single note&#10;note = Note.load('path/to/note.md')&#10;print(note.title)&#10;print(note.content)&#10;&#10;# Load all notes in a directory&#10;notes = Notes('path/to/vault')&#10;print(notes)&#10;```&#10;&#10;## Project Structure&#10;&#10;- `src/obsidianite/note.py`   - Note class for single note operations&#10;- `src/obsidianite/notes.py`  - Notes class for collections of notes&#10;- `src/tests/`                - Test suite&#10;&#10;## License&#10;&#10;MIT License&#10;&#10;## Disclaimer&#10;&#10;This project was created strictly for my own private use and is provided as-is. &#10;It is not a classic open source project with maintainers, ticket systems, or guaranteed fixes.&#10;If you want more features or changes, please fork the repository and implement them yourself.&#10;" />
              <option name="updatedContent" value="# Obsidianite&#10;&#10;A simple Python package to process Obsidian Markdown Notes.&#10;&#10;## Features&#10;- Load, process, and save Obsidian-compatible Markdown notes&#10;- Parse YAML front matter and note content&#10;- Work with collections of notes in a directory&#10;&#10;## Installation&#10;&#10;This project uses [uv](https://github.com/astral-sh/uv) for dependency management and installation.&#10;&#10;To install the project dependencies, run:&#10;&#10;```bash&#10;uv sync&#10;```&#10;&#10;Or, if you want to install the project in editable mode:&#10;&#10;```bash&#10;uv pip install -e .&#10;```&#10;&#10;## Testing&#10;&#10;To run the tests, use:&#10;&#10;```bash&#10;uv run pytest -v&#10;```&#10;&#10;## Usage Example&#10;&#10;```python&#10;from obsidianite import Note, Notes&#10;&#10;# Load a single note&#10;note = Note.load('path/to/note.md')&#10;print(note.title)&#10;print(note.content)&#10;&#10;# Load all notes in a directory&#10;notes = Notes('path/to/vault')&#10;print(notes)&#10;```&#10;&#10;## Project Structure&#10;&#10;- `src/obsidianite/note.py`   - Note class for single note operations&#10;- `src/obsidianite/notes.py`  - Notes class for collections of notes&#10;- `src/tests/`                - Test suite&#10;&#10;## License&#10;&#10;MIT License&#10;&#10;## Disclaimer&#10;&#10;This project was created for my own private use and is shared in the hope that it may be useful to others. Please note that it is not a classic open source project with maintainers, ticket systems, or guaranteed fixes. If you would like additional features or changes, feel free to fork the repository and adapt it to your needs. Enjoy using it as-is!" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/obsidianite/note.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/obsidianite/note.py" />
              <option name="originalContent" value="import os&#10;from typing import Any&#10;from yaml import safe_dump, safe_load&#10;from pathlib import Path&#10;from json import dumps&#10;&#10;&#10;class Note:&#10;    def __init__(self, title: str, content: str, properties: dict[str, Any], path: str = &quot;.&quot;):&#10;        self.title = title&#10;        self.content = content&#10;        self.properties = properties&#10;        self.path = path&#10;&#10;    def __repr__(self) -&gt; str:&#10;        return self.dump()&#10;&#10;    def dump(self) -&gt; str:&#10;        return dumps({&#10;            &quot;title&quot;: self.title,&#10;            &quot;path&quot;: self.path,&#10;            &quot;properties&quot;: self.properties,&#10;            &quot;content&quot;: self.content.strip()&#10;        }, indent=2, ensure_ascii=False)&#10;&#10;    def render(self) -&gt; str:&#10;       return f&quot;---\n{safe_dump(self.properties).strip()}\n---\n{self.content.strip()}&quot;&#10;&#10;    def save(self, filepath: str|None = None) -&gt; None:&#10;        if not filepath:&#10;            filepath = os.path.join(self.path,self.title + &quot;.md&quot;)&#10;        with open(filepath,&quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            f.write(self.render())&#10;&#10;    @classmethod&#10;    def load(cls, filepath: str) -&gt; &quot;Note&quot;:&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        title = p.stem&#10;        parent_path = p.parent.__str__()&#10;        with open(filepath, encoding=&quot;utf-8&quot;) as f:&#10;            md_text = f.read()&#10;            if md_text.startswith('---'):&#10;                parts = md_text.split('---', 2)&#10;                if len(parts) &gt;= 3:&#10;                    _, yaml_block, content = parts&#10;                    properties = safe_load(yaml_block.strip())&#10;                    return cls(title, content.strip(), properties, parent_path)&#10;            return cls(title, md_text, {}, parent_path)&#10;" />
              <option name="updatedContent" value="import os&#10;from typing import Any&#10;from yaml import safe_dump, safe_load&#10;from pathlib import Path&#10;from json import dumps&#10;&#10;&#10;class Note:&#10;    &quot;&quot;&quot;&#10;    Represents a single note with title, content, properties, and file path.&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self, title: str, content: str, properties: dict[str, Any], path: str = &quot;.&quot;):&#10;        &quot;&quot;&quot;&#10;        Initialize a Note instance.&#10;&#10;        Args:&#10;            title (str): The title of the note.&#10;            content (str): The main content of the note.&#10;            properties (dict[str, Any]): Metadata properties of the note.&#10;            path (str, optional): The directory path of the note. Defaults to &quot;.&quot;.&#10;        &quot;&quot;&quot;&#10;        self.title = title&#10;        self.content = content&#10;        self.properties = properties&#10;        self.path = path&#10;&#10;    def __repr__(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Return a string representation of the note (JSON format).&#10;&#10;        Returns:&#10;            str: JSON string of the note's data.&#10;        &quot;&quot;&quot;&#10;        return self.dump()&#10;&#10;    def dump(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Dump the note's data as a JSON string.&#10;&#10;        Returns:&#10;            str: JSON string of the note's data.&#10;        &quot;&quot;&quot;&#10;        return dumps({&#10;            &quot;title&quot;: self.title,&#10;            &quot;path&quot;: self.path,&#10;            &quot;properties&quot;: self.properties,&#10;            &quot;content&quot;: self.content.strip()&#10;        }, indent=2, ensure_ascii=False)&#10;&#10;    def render(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Render the note as a markdown string with YAML front matter.&#10;&#10;        Returns:&#10;            str: Markdown string with YAML front matter and content.&#10;        &quot;&quot;&quot;&#10;       return f&quot;---\n{safe_dump(self.properties).strip()}\n---\n{self.content.strip()}&quot;&#10;&#10;    def save(self, filepath: str|None = None) -&gt; None:&#10;        &quot;&quot;&quot;&#10;        Save the note to a markdown file.&#10;&#10;        Args:&#10;            filepath (str|None, optional): The file path to save the note. If None, uses the note's title and path.&#10;        &quot;&quot;&quot;&#10;        if not filepath:&#10;            filepath = os.path.join(self.path,self.title + &quot;.md&quot;)&#10;        with open(filepath,&quot;w&quot;, encoding=&quot;utf-8&quot;) as f:&#10;            f.write(self.render())&#10;&#10;    @classmethod&#10;    def load(cls, filepath: str) -&gt; &quot;Note&quot;:&#10;        &quot;&quot;&quot;&#10;        Load a note from a markdown file.&#10;&#10;        Args:&#10;            filepath (str): The path to the markdown file.&#10;&#10;        Returns:&#10;            Note: The loaded Note instance.&#10;&#10;        Raises:&#10;            FileNotFoundError: If the file does not exist.&#10;        &quot;&quot;&quot;&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        title = p.stem&#10;        parent_path = p.parent.__str__()&#10;        with open(filepath, encoding=&quot;utf-8&quot;) as f:&#10;            md_text = f.read()&#10;            if md_text.startswith('---'):&#10;                parts = md_text.split('---', 2)&#10;                if len(parts) &gt;= 3:&#10;                    _, yaml_block, content = parts&#10;                    properties = safe_load(yaml_block.strip())&#10;                    return cls(title, content.strip(), properties, parent_path)&#10;            return cls(title, md_text, {}, parent_path)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/obsidianite/notes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/obsidianite/notes.py" />
              <option name="originalContent" value="from pathlib import Path&#10;from .note import Note&#10;&#10;class Notes:&#10;    def __init__(self, filepath: str):&#10;        self.notes = []&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        md_files = list(p.rglob(&quot;*.md&quot;))&#10;        for md_file in md_files:&#10;            self.notes.append(Note.load(md_file.__str__()))&#10;&#10;    def __repr__(self) -&gt; str:&#10;        return &quot;\n&quot;.join([note.dump() for note in self.notes])" />
              <option name="updatedContent" value="from pathlib import Path&#10;from .note import Note&#10;&#10;class Notes:&#10;    def __init__(self, filepath: str):&#10;        &quot;&quot;&quot;&#10;        Initialize the Notes collection by loading all markdown (.md) files from the given directory path.&#10;        Args:&#10;            filepath (str): The path to the directory containing markdown files.&#10;        Raises:&#10;            FileNotFoundError: If the provided directory does not exist.&#10;        &quot;&quot;&quot;&#10;        self.notes = []&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        md_files = list(p.rglob(&quot;*.md&quot;))&#10;        for md_file in md_files:&#10;            self.notes.append(Note.load(md_file.__str__()))&#10;&#10;    def __repr__(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Return a string representation of all notes in the collection.&#10;        Returns:&#10;            str: A string with each note's dump output separated by newlines.&#10;        &quot;&quot;&quot;&#10;        return &quot;\n&quot;.join([note.dump() for note in self.notes])" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/test_note.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/test_note.py" />
              <option name="originalContent" value="from obsidianite import Note&#10;import os&#10;&#10;def test_note_creation() -&gt; Note:&#10;    note = Note(&quot;test&quot;,&quot;# Test&quot;,{&quot;kind&quot;:&quot;test&quot;},&quot;.&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;&#10;def test_note_save() -&gt; None:&#10;    note = Note(&quot;test&quot;,&quot;# Test&quot;,{&quot;kind&quot;:&quot;test&quot;},&quot;.&quot;)&#10;    note.save()&#10;    assert os.path.exists(os.path.join(note.path, note.title + &quot;.md&quot;))&#10;&#10;def test_note_load() -&gt; None:&#10;    note = Note.load(&quot;test.md&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;&#10;def test_note_render() -&gt; None:&#10;    note = Note(&quot;test&quot;,&quot;# Test&quot;,{&quot;kind&quot;:&quot;test&quot;},&quot;.&quot;)&#10;    assert note.render() == &quot;---\nkind: test\n---\n# Test&quot;&#10;&#10;def test_note_cleanup() -&gt; None:&#10;    os.remove(&quot;test.md&quot;)&#10;    assert not os.path.exists(&quot;test.md&quot;)" />
              <option name="updatedContent" value="from obsidianite import Note&#10;import os&#10;&#10;def test_note_creation() -&gt; Note:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Note object and verify its attributes.&#10;    Returns:&#10;        Note: The created Note object.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;,&quot;# Test&quot;,{&quot;kind&quot;:&quot;test&quot;},&quot;.&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;    return note&#10;&#10;def test_note_save() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test saving a Note object to a markdown file and check if the file exists.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;,&quot;# Test&quot;,{&quot;kind&quot;:&quot;test&quot;},&quot;.&quot;)&#10;    note.save()&#10;    assert os.path.exists(os.path.join(note.path, note.title + &quot;.md&quot;))&#10;&#10;def test_note_load() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test loading a Note object from a markdown file and verify its attributes.&#10;    &quot;&quot;&quot;&#10;    note = Note.load(&quot;test.md&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;&#10;def test_note_render() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test rendering a Note object to a markdown string with YAML front matter.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;,&quot;# Test&quot;,{&quot;kind&quot;:&quot;test&quot;},&quot;.&quot;)&#10;    assert note.render() == &quot;---\nkind: test\n---\n# Test&quot;&#10;&#10;def test_note_cleanup() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test cleanup by removing the test markdown file and verifying its removal.&#10;    &quot;&quot;&quot;&#10;    os.remove(&quot;test.md&quot;)&#10;    assert not os.path.exists(&quot;test.md&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/test_notes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/test_notes.py" />
              <option name="originalContent" value="import os&#10;import pytest&#10;from pathlib import Path&#10;from obsidianite import Notes, Note&#10;&#10;def test_notes_creation() -&gt; None:&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    assert isinstance(notes.notes,list)&#10;    assert len(notes.notes) == 2&#10;    assert isinstance(notes.notes[0],Note)" />
              <option name="updatedContent" value="import os&#10;import pytest&#10;from pathlib import Path&#10;from obsidianite import Notes, Note&#10;&#10;def test_notes_creation() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Notes collection from a directory and verify its contents.&#10;    Asserts that the notes attribute is a list, contains two notes, and that the first note is an instance of Note.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    assert isinstance(notes.notes,list)&#10;    assert len(notes.notes) == 2&#10;    assert isinstance(notes.notes[0],Note)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>