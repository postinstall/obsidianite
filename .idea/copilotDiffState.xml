<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/obsidianite/notes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/obsidianite/notes.py" />
              <option name="originalContent" value="from pathlib import Path&#10;from .note import Note&#10;&#10;class Notes:&#10;    def __init__(self, filepath: str):&#10;        &quot;&quot;&quot;&#10;        Initialize the Notes collection by loading all markdown (.md) files from the given directory path.&#10;        Args:&#10;            filepath (str): The path to the directory containing markdown files.&#10;        Raises:&#10;            FileNotFoundError: If the provided directory does not exist.&#10;        &quot;&quot;&quot;&#10;        self.notes = []&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        md_files = list(p.rglob(&quot;*.md&quot;))&#10;        for md_file in md_files:&#10;            self.notes.append(Note.load(md_file.__str__()))&#10;&#10;    def __repr__(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Return a string representation of all notes in the collection.&#10;        Returns:&#10;            str: A string with each note's dump output separated by newlines.&#10;        &quot;&quot;&quot;&#10;        return &quot;\n&quot;.join([note.dump() for note in self.notes])&#10;&#10;    def has_tags(self, tags):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain all of the specified tags.&#10;        Args:&#10;            tags (list or set): Tags to filter notes by.&#10;        Returns:&#10;            list: Notes that contain all specified tags.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if set(tags).issubset(set(note.tags()))]&#10;" />
              <option name="updatedContent" value="from pathlib import Path&#10;from .note import Note&#10;&#10;class Notes:&#10;    def __init__(self, filepath: str):&#10;        &quot;&quot;&quot;&#10;        Initialize the Notes collection by loading all markdown (.md) files from the given directory path.&#10;        Args:&#10;            filepath (str): The path to the directory containing markdown files.&#10;        Raises:&#10;            FileNotFoundError: If the provided directory does not exist.&#10;        &quot;&quot;&quot;&#10;        self.notes = []&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        md_files = list(p.rglob(&quot;*.md&quot;))&#10;        for md_file in md_files:&#10;            self.notes.append(Note.load(md_file.__str__()))&#10;&#10;    def __repr__(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Return a string representation of all notes in the collection.&#10;        Returns:&#10;            str: A string with each note's dump output separated by newlines.&#10;        &quot;&quot;&quot;&#10;        return &quot;\n&quot;.join([note.dump() for note in self.notes])&#10;&#10;    def has_tags(self, tags):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain all of the specified tags.&#10;        Args:&#10;            tags (list or set): Tags to filter notes by.&#10;        Returns:&#10;            list: Notes that contain all specified tags.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if set(tags).issubset(set(note.tags()))]&#10;&#10;    def has_any_tags(self, tags):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain any of the specified tags.&#10;        Args:&#10;            tags (list or set): Tags to filter notes by.&#10;        Returns:&#10;            list: Notes that contain at least one of the specified tags.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if set(tags) &amp; set(note.tags())]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/test_notes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/test_notes.py" />
              <option name="originalContent" value="import os&#10;from pathlib import Path&#10;from obsidianite import Notes, Note&#10;&#10;&#10;def test_notes_creation() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Notes collection from a directory and verify its contents.&#10;    Asserts that the notes attribute is a list, contains two notes, and that the first note is an instance of Note.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    assert isinstance(notes.notes, list)&#10;    assert len(notes.notes) == 2&#10;    assert isinstance(notes.notes[0], Note)&#10;&#10;" />
              <option name="updatedContent" value="import os&#10;from pathlib import Path&#10;from obsidianite import Notes, Note&#10;&#10;&#10;def test_notes_creation() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Notes collection from a directory and verify its contents.&#10;    Asserts that the notes attribute is a list, contains two notes, and that the first note is an instance of Note.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    assert isinstance(notes.notes, list)&#10;    assert len(notes.notes) == 2&#10;    assert isinstance(notes.notes[0], Note)&#10;&#10;&#10;def test_has_tags_and_has_any_tags():&#10;    &quot;&quot;&quot;&#10;    Test the has_tags and has_any_tags methods of the Notes class.&#10;    Assumes the test vault contains notes with tags 'test', 'foo', and 'bar'.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    # Test has_tags: only notes containing both 'test' and 'foo'&#10;    notes_with_both = notes.has_tags(['test', 'foo'])&#10;    for note in notes_with_both:&#10;        assert set(['test', 'foo']).issubset(set(note.tags()))&#10;    # Test has_any_tags: notes containing at least one of 'test' or 'bar'&#10;    notes_with_any = notes.has_any_tags(['test', 'bar'])&#10;    for note in notes_with_any:&#10;        assert set(['test', 'bar']) &amp; set(note.tags())" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>