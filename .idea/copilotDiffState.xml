<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Obsidianite&#10;&#10;A simple Python package to process Obsidian Markdown Notes.&#10;&#10;## Features&#10;- Load, process, and save Obsidian-compatible Markdown notes&#10;- Parse YAML front matter and note content&#10;- Work with collections of notes in a directory&#10;&#10;## Installation&#10;&#10;This project uses [uv](https://github.com/astral-sh/uv) for dependency management and installation.&#10;&#10;To install the project dependencies, run:&#10;&#10;```bash&#10;uv sync&#10;```&#10;&#10;Or, if you want to install the project in editable mode:&#10;&#10;```bash&#10;uv pip install -e .&#10;```&#10;&#10;## Testing&#10;&#10;To run the tests, use:&#10;&#10;```bash&#10;uv run pytest -v&#10;```&#10;&#10;## Usage Example&#10;&#10;```python&#10;from obsidianite import Note, Notes&#10;&#10;# Load a single note&#10;note = Note.load('path/to/note.md')&#10;print(note.title)&#10;print(note.content)&#10;&#10;# Load all notes in a directory&#10;notes = Notes('path/to/vault')&#10;print(notes)&#10;```&#10;&#10;## Project Structure&#10;&#10;- `src/obsidianite/note.py`   - Note class for single note operations&#10;- `src/obsidianite/notes.py`  - Notes class for collections of notes&#10;- `src/tests/`                - Test suite&#10;&#10;## License&#10;&#10;MIT License&#10;&#10;## Disclaimer&#10;&#10;This project was created for my own private use and is shared in the hope that it may be useful to others. &#10;Please note that it is not a classic open source project with maintainers, ticket systems, or guaranteed fixes.&#10;If you would like additional features or changes, feel free to fork the repository and adapt it to your needs.&#10;Enjoy using it as-is!&#10;" />
              <option name="updatedContent" value="# Obsidianite&#10;&#10;A simple Python package to process Obsidian Markdown Notes.&#10;&#10;## Features&#10;- Load, process, and save Obsidian-compatible Markdown notes&#10;- Parse YAML front matter and note content&#10;- Work with collections of notes in a directory&#10;&#10;## Installation&#10;&#10;This project uses [uv](https://github.com/astral-sh/uv) for dependency management and installation.&#10;&#10;To install the project dependencies, run:&#10;&#10;```bash&#10;uv sync&#10;```&#10;&#10;Or, if you want to install the project in editable mode:&#10;&#10;```bash&#10;uv pip install -e .&#10;```&#10;&#10;## Testing&#10;&#10;To run the tests, use:&#10;&#10;```bash&#10;uv run pytest -v&#10;```&#10;&#10;## Usage Example&#10;&#10;```python&#10;from obsidianite import Note, Notes&#10;&#10;# Load a single note&#10;note = Note.load('path/to/note.md')&#10;print(note.title)&#10;print(note.content)&#10;&#10;# Load all notes in a directory&#10;notes = Notes('path/to/vault')&#10;print(notes)&#10;&#10;# Filter notes by tags (all tags must be present)&#10;notes_with_tags = notes.has_tags(['project', 'python'])&#10;for n in notes_with_tags:&#10;    print(n.title, n.tags())&#10;&#10;# Filter notes by any tag (at least one must be present)&#10;notes_with_any_tag = notes.has_any_tags(['project', 'python'])&#10;for n in notes_with_any_tag:&#10;    print(n.title, n.tags())&#10;&#10;# Filter notes by properties (e.g., kind=&quot;test&quot;)&#10;filtered_notes = list(notes.filter(kind=&quot;test&quot;))&#10;for n in filtered_notes:&#10;    print(n.title, n.properties)&#10;```&#10;&#10;## Project Structure&#10;&#10;- `src/obsidianite/note.py`   - Note class for single note operations&#10;- `src/obsidianite/notes.py`  - Notes class for collections of notes&#10;- `src/tests/`                - Test suite&#10;&#10;## License&#10;&#10;MIT License&#10;&#10;## Disclaimer&#10;&#10;This project was created for my own private use and is shared in the hope that it may be useful to others. &#10;Please note that it is not a classic open source project with maintainers, ticket systems, or guaranteed fixes.&#10;If you would like additional features or changes, feel free to fork the repository and adapt it to your needs.&#10;Enjoy using it as-is!" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main.py" />
              <option name="originalContent" value="from obsidianite import Notes, Note&#10;import mistune&#10;import re&#10;&#10;markdown = mistune.create_markdown(renderer=None)&#10;&#10;def insert_string_after_heading(content, heading, insert_str):&#10;    &quot;&quot;&quot;&#10;    Insert a string after a heading with the given level and title.&#10;    Args:&#10;        content (str): The markdown content.&#10;        heading (str): The heading, e.g. '## Links' or '# Title'.&#10;        insert_str (str): The string to insert after the heading.&#10;    Returns:&#10;        str: The modified markdown content.&#10;    &quot;&quot;&quot;&#10;    import re&#10;    # Extrahiere Level und Titel&#10;    match = re.match(r'^(#+)\s+(.*)$', heading)&#10;    if not match:&#10;        raise ValueError(&quot;heading must be in the form '# Title' or '## Links'&quot;)&#10;    hashes, title = match.groups()&#10;    pattern = rf'(^{'#' * len(hashes)} +{re.escape(title)}.*?$)'&#10;    replacement = r&quot;\1\n&quot; + insert_str&#10;    return re.sub(pattern, replacement, content, flags=re.MULTILINE)&#10;&#10;# Lade die Notiz&#10;note = Note.load(&quot;tests/data/vault/folder/data.md&quot;)&#10;&#10;# Füge nach einem H2-Heading mit dem Titel &quot;Links&quot; den Text &quot;- TEst&quot; ein&#10;new_content = insert_string_after_heading(note.content, &quot;## Links&quot;, &quot;- TEst&quot;)&#10;&#10;# Optional: Ausgabe oder speichern&#10;print(new_content)&#10;# note.content = new_content&#10;# note.save()&#10;" />
              <option name="updatedContent" value="from obsidianite import Notes, Note&#10;import mistune&#10;import re&#10;&#10;markdown = mistune.create_markdown(renderer=None)&#10;&#10;def insert_string_after_heading(content, heading, insert_str):&#10;    &quot;&quot;&quot;&#10;    Insert a string after a heading with the given level and title.&#10;    Args:&#10;        content (str): The markdown content.&#10;        heading (str): The heading, e.g. '## Links' or '# Title'.&#10;        insert_str (str): The string to insert after the heading.&#10;    Returns:&#10;        str: The modified markdown content.&#10;    &quot;&quot;&quot;&#10;    import re&#10;    # Extrahiere Level und Titel&#10;    match = re.match(r'^(#+)\s+(.*)$', heading)&#10;    if not match:&#10;        raise ValueError(&quot;heading must be in the form '# Title' or '## Links'&quot;)&#10;    hashes, title = match.groups()&#10;    pattern = r'(^' + ('#' * len(hashes)) + r' +' + re.escape(title) + r'.*?$)'&#10;    replacement = r&quot;\1\n&quot; + insert_str&#10;    return re.sub(pattern, replacement, content, flags=re.MULTILINE)&#10;&#10;# Lade die Notiz&#10;note = Note.load(&quot;tests/data/vault/folder/data.md&quot;)&#10;&#10;# Füge nach einem H2-Heading mit dem Titel &quot;Links&quot; den Text &quot;- TEst&quot; ein&#10;new_content = insert_string_after_heading(note.content, &quot;## Links&quot;, &quot;- TEst&quot;)&#10;&#10;# Optional: Ausgabe oder speichern&#10;print(new_content)&#10;# note.content = new_content&#10;# note.save()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/obsidianite/notes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/obsidianite/notes.py" />
              <option name="originalContent" value="from pathlib import Path&#10;from .note import Note&#10;&#10;class Notes:&#10;    def __init__(self, filepath: str):&#10;        &quot;&quot;&quot;&#10;        Initialize the Notes collection by loading all markdown (.md) files from the given directory path.&#10;        Args:&#10;            filepath (str): The path to the directory containing markdown files.&#10;        Raises:&#10;            FileNotFoundError: If the provided directory does not exist.&#10;        &quot;&quot;&quot;&#10;        self.notes = []&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        md_files = list(p.rglob(&quot;*.md&quot;))&#10;        for md_file in md_files:&#10;            self.notes.append(Note.load(md_file.__str__()))&#10;&#10;    def __repr__(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Return a string representation of all notes in the collection.&#10;        Returns:&#10;            str: A string with each note's dump output separated by newlines.&#10;        &quot;&quot;&quot;&#10;        return &quot;\n&quot;.join([note.dump() for note in self.notes])&#10;&#10;    def has_tags(self, tags):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain all of the specified tags.&#10;        Args:&#10;            tags (list or set): Tags to filter notes by.&#10;        Returns:&#10;            list: Notes that contain all specified tags.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if set(tags).issubset(set(note.tags()))]&#10;&#10;    def has_any_tags(self, tags):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain any of the specified tags.&#10;        Args:&#10;            tags (list or set): Tags to filter notes by.&#10;        Returns:&#10;            list: Notes that contain at least one of the specified tags.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if set(tags) &amp; set(note.tags())]&#10;&#10;    def filter(self, **properties):&#10;        &quot;&quot;&quot;&#10;        Return a generator of notes that match all specified properties.&#10;        Args:&#10;            **properties: Arbitrary keyword arguments representing note properties and their expected values.&#10;        Returns:&#10;            generator: Notes that match all specified properties.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if all(note.properties.get(k) == v for k, v in properties.items())]&#10;" />
              <option name="updatedContent" value="from pathlib import Path&#10;from .note import Note&#10;&#10;class Notes:&#10;    def __init__(self, filepath: str):&#10;        &quot;&quot;&quot;&#10;        Initialize the Notes collection by loading all markdown (.md) files from the given directory path.&#10;        Args:&#10;            filepath (str): The path to the directory containing markdown files.&#10;        Raises:&#10;            FileNotFoundError: If the provided directory does not exist.&#10;        &quot;&quot;&quot;&#10;        self.notes = []&#10;        p = Path(filepath)&#10;        if not p.exists():&#10;            raise FileNotFoundError(f&quot;Datei nicht gefunden: {filepath}&quot;)&#10;        md_files = list(p.rglob(&quot;*.md&quot;))&#10;        for md_file in md_files:&#10;            self.notes.append(Note.load(md_file.__str__()))&#10;&#10;    def __repr__(self) -&gt; str:&#10;        &quot;&quot;&quot;&#10;        Return a string representation of all notes in the collection.&#10;        Returns:&#10;            str: A string with each note's dump output separated by newlines.&#10;        &quot;&quot;&quot;&#10;        return &quot;\n&quot;.join([note.dump() for note in self.notes])&#10;&#10;    def has_tags(self, tags):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain all of the specified tags.&#10;        Args:&#10;            tags (list or set): Tags to filter notes by.&#10;        Returns:&#10;            list: Notes that contain all specified tags.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if set(tags).issubset(set(note.tags()))]&#10;&#10;    def has_any_tags(self, tags):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain any of the specified tags.&#10;        Args:&#10;            tags (list or set): Tags to filter notes by.&#10;        Returns:&#10;            list: Notes that contain at least one of the specified tags.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if set(tags) &amp; set(note.tags())]&#10;&#10;    def filter(self, **properties):&#10;        &quot;&quot;&quot;&#10;        Return a generator of notes that match all specified properties.&#10;        Args:&#10;            **properties: Arbitrary keyword arguments representing note properties and their expected values.&#10;        Returns:&#10;            generator: Notes that match all specified properties.&#10;        &quot;&quot;&quot;&#10;        return [note for note in self.notes if all(note.properties.get(k) == v for k, v in properties.items())]&#10;&#10;    def has(self, tags=None, **properties):&#10;        &quot;&quot;&quot;&#10;        Return a list of notes that contain all specified tags and match all specified properties.&#10;        Args:&#10;            tags (list or set, optional): Tags to filter notes by. All tags must be present in the note.&#10;            **properties: Arbitrary keyword arguments representing note properties and their expected values.&#10;        Returns:&#10;            list: Notes that match all specified tags and properties.&#10;        &quot;&quot;&quot;&#10;        return [&#10;            note for note in self.notes&#10;            if (tags is None or set(tags).issubset(set(note.tags())))&#10;            and all(note.properties.get(k) == v for k, v in properties.items())&#10;        ]" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/test_helper.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/test_helper.py" />
              <option name="originalContent" value="from obsidianite import insert_string_after_heading&#10;&#10;def test_insert_string_after_heading():&#10;    &quot;&quot;&quot;&#10;    Test insert_string_after_heading by inserting a string after a heading of any level.&#10;    &quot;&quot;&quot;&#10;    content = &quot;&quot;&quot;# Title&#10;Some intro&#10;&#10;## Links&#10;Old content&#10;&#10;## Other&#10;&quot;&quot;&quot;&#10;    # Insert after '## Links'&#10;    result = insert_string_after_heading(content, &quot;## Links&quot;, &quot;- Inserted item&quot;)&#10;    assert &quot;## Links\n- Inserted item&quot; in result&#10;    # Insert after '# Title'&#10;    result2 = insert_string_after_heading(content, &quot;# Title&quot;, &quot;Paragraph after title&quot;)&#10;    assert &quot;# Title\nParagraph after title&quot; in result2&#10;    # Insert after non-existing heading&#10;    result3 = insert_string_after_heading(content, &quot;### NotThere&quot;, &quot;Should not appear&quot;)&#10;    assert &quot;Should not appear&quot; not in result3&#10;&#10;" />
              <option name="updatedContent" value="from obsidianite import insert_string_after_heading&#10;&#10;def test_insert_string_after_heading():&#10;    &quot;&quot;&quot;&#10;    Test insert_string_after_heading by inserting a string after a heading of any level.&#10;    &quot;&quot;&quot;&#10;    content = &quot;# Title\nSome intro\n\n## Links\nOld content\n\n## Other\n&quot;&#10;    # Insert after '## Links'&#10;    result = insert_string_after_heading(content, &quot;## Links&quot;, &quot;- Inserted item&quot;)&#10;    assert &quot;## Links\n- Inserted item&quot; in result&#10;    # Insert after '# Title'&#10;    result2 = insert_string_after_heading(content, &quot;# Title&quot;, &quot;Paragraph after title&quot;)&#10;    assert &quot;# Title\nParagraph after title&quot; in result2&#10;    # Insert after non-existing heading&#10;    result3 = insert_string_after_heading(content, &quot;### NotThere&quot;, &quot;Should not appear&quot;)&#10;    assert &quot;Should not appear&quot; not in result3" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/test_note.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/test_note.py" />
              <option name="originalContent" value="from obsidianite import Note&#10;import os&#10;&#10;&#10;def test_note_creation() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Note object and verify its attributes.&#10;    Returns:&#10;        Note: The created Note object.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {&quot;kind&quot;: &quot;test&quot;}, &quot;.&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;&#10;&#10;def test_note_save() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test saving a Note object to a markdown file and check if the file exists.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {&quot;kind&quot;: &quot;test&quot;}, &quot;.&quot;)&#10;    note.save()&#10;    assert os.path.exists(os.path.join(note.path, note.title + &quot;.md&quot;))&#10;&#10;&#10;def test_note_load() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test loading a Note object from a markdown file and verify its attributes.&#10;    &quot;&quot;&quot;&#10;    note = Note.load(&quot;test.md&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;&#10;&#10;def test_note_render() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test rendering a Note object to a markdown string with YAML front matter.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {&quot;kind&quot;: &quot;test&quot;}, &quot;.&quot;)&#10;    assert note.render() == &quot;---\nkind: test\n---\n# Test&quot;&#10;&#10;&#10;def test_note_cleanup() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test cleanup by removing the test markdown file and verifying its removal.&#10;    &quot;&quot;&quot;&#10;    os.remove(&quot;test.md&quot;)&#10;    assert not os.path.exists(&quot;test.md&quot;)&#10;&#10;&#10;def test_note_tags() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test extracting tags from a Note object.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test #tag1 #tag2&quot;, {&quot;tags&quot;: [&quot;tag3&quot;]}, &quot;.&quot;)&#10;    tags = note.tags()&#10;    assert &quot;tag1&quot; in tags&#10;    assert &quot;tag2&quot; in tags&#10;    assert &quot;tag3&quot; in tags&#10;    assert len(tags) == 3  # Ensure no duplicates&#10;&#10;&#10;def test_note_fullpath() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the fullpath method of a Note object.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {}, &quot;.&quot;)&#10;    expected = os.path.abspath(&quot;test.md&quot;)&#10;    assert note.fullpath() == expected&#10;" />
              <option name="updatedContent" value="from obsidianite import Note&#10;import os&#10;&#10;&#10;def test_note_creation() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Note object and verify its attributes.&#10;    Returns:&#10;        Note: The created Note object.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {&quot;kind&quot;: &quot;test&quot;}, &quot;.&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;&#10;&#10;def test_note_save() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test saving a Note object to a markdown file and check if the file exists.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {&quot;kind&quot;: &quot;test&quot;}, &quot;.&quot;)&#10;    note.save()&#10;    assert os.path.exists(os.path.join(note.path, note.title + &quot;.md&quot;))&#10;&#10;&#10;def test_note_load() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test loading a Note object from a markdown file and verify its attributes.&#10;    &quot;&quot;&quot;&#10;    note = Note.load(&quot;test.md&quot;)&#10;    assert note.content == &quot;# Test&quot;&#10;    assert note.properties == {&quot;kind&quot;: &quot;test&quot;}&#10;    assert note.title == &quot;test&quot;&#10;    assert note.path == &quot;.&quot;&#10;&#10;&#10;def test_note_render() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test rendering a Note object to a markdown string with YAML front matter.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {&quot;kind&quot;: &quot;test&quot;}, &quot;.&quot;)&#10;    assert note.render() == &quot;---\nkind: test\n---\n# Test&quot;&#10;&#10;&#10;def test_note_cleanup() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test cleanup by removing the test markdown file and verifying its removal.&#10;    &quot;&quot;&quot;&#10;    os.remove(&quot;test.md&quot;)&#10;    assert not os.path.exists(&quot;test.md&quot;)&#10;&#10;&#10;def test_note_tags() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test extracting tags from a Note object.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test #tag1 #tag2&quot;, {&quot;tags&quot;: [&quot;tag3&quot;]}, &quot;.&quot;)&#10;    tags = note.tags()&#10;    assert &quot;tag1&quot; in tags&#10;    assert &quot;tag2&quot; in tags&#10;    assert &quot;tag3&quot; in tags&#10;    assert len(tags) == 3  # Ensure no duplicates&#10;&#10;&#10;def test_note_fullpath() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the fullpath method of a Note object.&#10;    &quot;&quot;&quot;&#10;    note = Note(&quot;test&quot;, &quot;# Test&quot;, {}, &quot;.&quot;)&#10;    expected = os.path.abspath(os.path.join(note.path, note.title + &quot;.md&quot;))&#10;    assert note.fullpath() == expected" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/tests/test_notes.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/tests/test_notes.py" />
              <option name="originalContent" value="import os&#10;from pathlib import Path&#10;from obsidianite import Notes, Note&#10;&#10;&#10;def test_notes_creation() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Notes collection from a directory and verify its contents.&#10;    Asserts that the notes attribute is a list, contains two notes, and that the first note is an instance of Note.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    assert isinstance(notes.notes, list)&#10;    assert len(notes.notes) == 2&#10;    assert isinstance(notes.notes[0], Note)&#10;&#10;&#10;def test_has_tags_and_has_any_tags():&#10;    &quot;&quot;&quot;&#10;    Test the has_tags and has_any_tags methods of the Notes class.&#10;    Assumes the test vault contains notes with tags 'test', 'foo', and 'bar'.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    notes_with_both = notes.has_tags(['test', 'data'])&#10;    for note in notes_with_both:&#10;        assert set(['test', 'data']).issubset(set(note.tags()))&#10;    notes_with_any = notes.has_any_tags(['test', 'data'])&#10;    for note in notes_with_any:&#10;        assert set(['test', 'data']) &amp; set(note.tags())&#10;&#10;&#10;def test_filter_properties():&#10;    &quot;&quot;&quot;&#10;    Test the filter method of the Notes class by filtering for specific properties.&#10;    Expects that all returned notes have the required properties.&#10;    Also checks that filtering for a non-existent property returns an empty result.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    filtered = notes.filter(kind=&quot;test&quot;)&#10;    for note in filtered:&#10;        assert note.properties.get(&quot;kind&quot;) == &quot;test&quot;&#10;    assert notes.filter(foo=&quot;bar&quot;) == []&#10;" />
              <option name="updatedContent" value="import os&#10;from pathlib import Path&#10;from obsidianite import Notes, Note&#10;&#10;&#10;def test_notes_creation() -&gt; None:&#10;    &quot;&quot;&quot;&#10;    Test the creation of a Notes collection from a directory and verify its contents.&#10;    Asserts that the notes attribute is a list, contains two notes, and that the first note is an instance of Note.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    assert isinstance(notes.notes, list)&#10;    assert len(notes.notes) == 2&#10;    assert isinstance(notes.notes[0], Note)&#10;&#10;&#10;def test_has_tags_and_has_any_tags():&#10;    &quot;&quot;&quot;&#10;    Test the has_tags and has_any_tags methods of the Notes class.&#10;    Assumes the test vault contains notes with tags 'test', 'foo', and 'bar'.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    notes_with_both = notes.has_tags(['test', 'data'])&#10;    for note in notes_with_both:&#10;        assert set(['test', 'data']).issubset(set(note.tags()))&#10;    notes_with_any = notes.has_any_tags(['test', 'data'])&#10;    for note in notes_with_any:&#10;        assert set(['test', 'data']) &amp; set(note.tags())&#10;&#10;&#10;def test_filter_properties():&#10;    &quot;&quot;&quot;&#10;    Test the filter method of the Notes class by filtering for specific properties.&#10;    Expects that all returned notes have the required properties.&#10;    Also checks that filtering for a non-existent property returns an empty result.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    filtered = notes.filter(kind=&quot;test&quot;)&#10;    for note in filtered:&#10;        assert note.properties.get(&quot;kind&quot;) == &quot;test&quot;&#10;    assert notes.filter(foo=&quot;bar&quot;) == []&#10;&#10;&#10;def test_has_combined():&#10;    &quot;&quot;&quot;&#10;    Test the has method of the Notes class, which combines tag and property filtering.&#10;    Checks that only notes with all specified tags and properties are returned.&#10;    &quot;&quot;&quot;&#10;    notes = Notes(os.path.join(Path(__file__).parent, &quot;data/vault&quot;))&#10;    # Beispiel: Suche nach Notizen mit Tag 'test' und Property kind=&quot;test&quot;&#10;    filtered = notes.has(tags=[&quot;test&quot;], kind=&quot;test&quot;)&#10;    for note in filtered:&#10;        assert &quot;test&quot; in note.tags()&#10;        assert note.properties.get(&quot;kind&quot;) == &quot;test&quot;&#10;    # Test: Keine Notiz mit Tag 'notag' und Property foo=&quot;bar&quot;&#10;    assert notes.has(tags=[&quot;notag&quot;], foo=&quot;bar&quot;) == []" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>